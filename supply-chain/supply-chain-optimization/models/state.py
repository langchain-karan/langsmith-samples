from typing import TypedDict, List, Dict, Optional, Annotated, Any
from datetime import datetime
from pydantic import BaseModel, Field
import operator


class SKU(BaseModel):
    """Product SKU with attributes"""
    sku_id: str
    name: str
    category: str
    is_perishable: bool = False
    shelf_life_days: Optional[int] = None
    unit_cost: float
    supplier_ids: List[str] = Field(default_factory=list)


class InventoryLevel(BaseModel):
    """Current inventory at a location"""
    sku_id: str
    location_id: str
    quantity: int
    reorder_point: int
    safety_stock: int
    last_updated: datetime = Field(default_factory=datetime.now)


class DemandForecast(BaseModel):
    """Demand forecast for SKU at location"""
    sku_id: str
    location_id: str
    date: datetime
    predicted_demand: float
    confidence_lower: float
    confidence_upper: float
    mape: Optional[float] = None  # Mean Absolute Percentage Error
    factors: Dict[str, float] = Field(default_factory=dict)  # seasonality, weather, etc.


class Supplier(BaseModel):
    """Supplier information"""
    supplier_id: str
    name: str
    lead_time_days: int
    reliability_score: float  # 0-1
    cost_factor: float  # multiplier on base cost


class PurchaseOrder(BaseModel):
    """Purchase order generated by inventory agent"""
    po_id: str
    sku_id: str
    supplier_id: str
    quantity: int
    destination_location: str
    expected_delivery: datetime
    total_cost: float
    priority: str = "normal"  # normal, urgent, critical
    status: str = "pending"  # pending, confirmed, shipped, delivered


class LogisticsRoute(BaseModel):
    """Optimized route for delivery"""
    route_id: str
    po_ids: List[str]
    carrier: str
    origin: str
    destination: str
    waypoints: List[str] = Field(default_factory=list)
    estimated_duration_hours: float
    estimated_cost: float
    status: str = "planned"  # planned, in_transit, disrupted, completed


class Disruption(BaseModel):
    """Supply chain disruption event"""
    disruption_id: str
    type: str  # weather, traffic, supplier_failure, port_congestion
    affected_routes: List[str] = Field(default_factory=list)
    affected_suppliers: List[str] = Field(default_factory=list)
    severity: str  # low, medium, high, critical
    detected_at: datetime = Field(default_factory=datetime.now)
    estimated_resolution: Optional[datetime] = None
    mitigation_action: Optional[str] = None


class ExternalSignals(BaseModel):
    """External data signals for forecasting"""
    weather_data: Dict[str, Any] = Field(default_factory=dict)
    social_trends: Dict[str, Any] = Field(default_factory=dict)
    economic_indicators: Dict[str, Any] = Field(default_factory=dict)
    port_congestion: Dict[str, Any] = Field(default_factory=dict)


class AgentMessage(BaseModel):
    """Message between agents"""
    from_agent: str
    to_agent: str
    message_type: str
    content: Dict[str, Any]
    timestamp: datetime = Field(default_factory=datetime.now)
    priority: str = "normal"


class SupplyChainState(TypedDict):
    """State object that flows through the LangGraph"""

    # Core data
    skus: List[SKU]
    inventory_levels: List[InventoryLevel]
    suppliers: List[Supplier]

    # Agent outputs
    demand_forecasts: Annotated[List[DemandForecast], operator.add]
    purchase_orders: Annotated[List[PurchaseOrder], operator.add]
    logistics_routes: Annotated[List[LogisticsRoute], operator.add]
    disruptions: Annotated[List[Disruption], operator.add]

    # External data
    external_signals: Optional[ExternalSignals]

    # Inter-agent communication
    messages: Annotated[List[AgentMessage], operator.add]

    # Orchestration
    current_agent: Optional[str]
    next_agent: Optional[str]
    requires_human_review: bool
    alerts: Annotated[List[str], operator.add]

    # Metadata
    iteration: int
    timestamp: datetime
